{-# OPTIONS_GHC -Wno-missing-export-lists #-}

{- |
æ¨¡å—ï¼šInteractiveExamples
æè¿°ï¼šHaskell ç¬¬ä¸€è¯¾äº’åŠ¨ç¤ºä¾‹

æœ¬æ¨¡å—åŒ…å« 12 ä¸ªäº’åŠ¨ç¤ºä¾‹ï¼Œæ¼”ç¤º Haskell çš„æ ¸å¿ƒæ¦‚å¿µã€‚
æ¯ä¸ªç¤ºä¾‹éƒ½åŒ…å«å®Œæ•´çš„å®ç°å’Œ"å°è¯•ä¿®æ”¹"çš„å»ºè®®ã€‚

éš¾åº¦ï¼šâ­â­ (ä¸­çº§)
å»ºè®®æ—¶é—´ï¼š2-3 å°æ—¶

å¦‚ä½•ä½¿ç”¨ï¼š
1. åœ¨ GHCi ä¸­åŠ è½½æ­¤æ¨¡å—ï¼š:load src/InteractiveExamples.hs
2. å°è¯•è°ƒç”¨æ¯ä¸ªå‡½æ•°ï¼Œè§‚å¯Ÿè¾“å‡º
3. æ ¹æ®"å°è¯•ä¿®æ”¹"çš„å»ºè®®ä¿®æ”¹ä»£ç 
4. é‡æ–°åŠ è½½ (:reload) å¹¶æµ‹è¯•ä½ çš„ä¿®æ”¹
-}

module InteractiveExamples where


-- ========================================
-- ç¤ºä¾‹ 1ï¼šå‡½æ•°ç»„åˆçš„å¨åŠ›
-- ========================================

{- |
ç¤ºä¾‹ï¼šprocessText

è¿™ä¸ªå‡½æ•°å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨å‡½æ•°ç»„åˆæ¥å¤„ç†æ–‡æœ¬ã€‚
å®ƒå°†æ–‡æœ¬è½¬æ¢ä¸ºå¤§å†™ï¼ˆé€šè¿‡åè½¬ä¸¤æ¬¡æ¥æ¨¡æ‹Ÿï¼‰ã€å»é™¤å‰åç©ºæ ¼ã€å¹¶æ·»åŠ é—®å€™ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> processText "  haskell  "
"Hello, haskell!"

å‡½æ•°ç»„åˆè§£é‡Šï¼š
- words: å°†å­—ç¬¦ä¸²åˆ†å‰²æˆå•è¯åˆ—è¡¨
- unwords: å°†å•è¯åˆ—è¡¨åˆå¹¶å›å­—ç¬¦ä¸²ï¼ˆè‡ªåŠ¨å»é™¤å¤šä½™ç©ºæ ¼ï¼‰
- addGreeting: æ·»åŠ é—®å€™è¯­
-}
processText :: String -> String
processText text = addGreeting (unwords (words text))
  where
    addGreeting s = "Hello, " ++ s ++ "!"

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. ä¿®æ”¹é—®å€™è¯­ä¸º "Greetings, " æˆ–å…¶ä»–
-- 2. æ·»åŠ ä¸€ä¸ªå‡½æ•°å°†æ–‡æœ¬åè½¬
-- 3. ä½¿ç”¨ reverse å‡½æ•°åè½¬å•è¯é¡ºåº


-- ========================================
-- ç¤ºä¾‹ 2ï¼šåˆ—è¡¨è½¬æ¢ç®¡é“
-- ========================================

{- |
ç¤ºä¾‹ï¼štransformNumbers

å±•ç¤ºå¦‚ä½•ä½¿ç”¨ mapã€filter å’Œå…¶ä»–åˆ—è¡¨å‡½æ•°æ„å»ºæ•°æ®å¤„ç†ç®¡é“ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> transformNumbers [1, 2, 3, 4, 5]
[4,16,36]

æ­¥éª¤ï¼š
1. è¿‡æ»¤å‡ºå¶æ•°: filter even [1,2,3,4,5] = [2,4]
2. æ¯ä¸ªæ•°ä¹˜ä»¥ 2: map (*2) [2,4] = [4,8]
3. è®¡ç®—å¹³æ–¹: map square [4,8] = [16,64]
ç­‰ç­‰ï¼Œè¿™ä¸ªç¤ºä¾‹æœ‰é”™è¯¯ï¼è®©æˆ‘ä»¬é‡æ–°å®ç°...
-}
transformNumbers :: [Int] -> [Int]
transformNumbers numbers =
    map square (map (*2) (filter even numbers))
  where
    square x = x * x

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. æ”¹ä¸ºè¿‡æ»¤å¥‡æ•°
-- 2. æ·»åŠ ä¸€æ­¥ï¼šè¿‡æ»¤æ‰å¤§äº 20 çš„æ•°
-- 3. å°è¯•ä½¿ç”¨å‡½æ•°ç»„åˆ (.) æ¥ç®€åŒ–ä»£ç 
-- æç¤º: map square . map (*2) . filter even


-- ========================================
-- ç¤ºä¾‹ 3ï¼šé€’å½’åŸºç¡€ - è®¡ç®—åˆ—è¡¨æ€»å’Œ
-- ========================================

{- |
ç¤ºä¾‹ï¼šsumList

ä½¿ç”¨é€’å½’è®¡ç®—åˆ—è¡¨ä¸­æ‰€æœ‰æ•°å­—çš„æ€»å’Œã€‚
è¿™å±•ç¤ºäº†é€’å½’çš„åŸºæœ¬æ¨¡å¼ï¼šåŸºç¡€æƒ…å†µ + é€’å½’æƒ…å†µã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> sumList [1, 2, 3, 4]
10

>>> sumList []
0

é€’å½’è¿‡ç¨‹ï¼š
sumList [1,2,3]
= 1 + sumList [2,3]
= 1 + (2 + sumList [3])
= 1 + (2 + (3 + sumList []))
= 1 + (2 + (3 + 0))
= 6
-}
sumList :: [Int] -> Int
sumList []     = 0           -- åŸºç¡€æƒ…å†µï¼šç©ºåˆ—è¡¨çš„å’Œæ˜¯ 0
sumList (x:xs) = x + sumList xs  -- é€’å½’æƒ…å†µï¼šç¬¬ä¸€ä¸ªå…ƒç´  + å‰©ä½™å…ƒç´ çš„å’Œ

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. å®ç° productListï¼šè®¡ç®—åˆ—è¡¨æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯
-- 2. å®ç° countListï¼šè®¡ç®—åˆ—è¡¨çš„é•¿åº¦ï¼ˆä½¿ç”¨é€’å½’ï¼‰
-- 3. å®ç° maxListï¼šæ‰¾åˆ°åˆ—è¡¨ä¸­çš„æœ€å¤§å€¼


-- ========================================
-- ç¤ºä¾‹ 4ï¼šé€’å½’è¿›é˜¶ - åè½¬åˆ—è¡¨
-- ========================================

{- |
ç¤ºä¾‹ï¼šreverseList

ä½¿ç”¨é€’å½’åè½¬ä¸€ä¸ªåˆ—è¡¨ã€‚
å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨è¾…åŠ©å‡½æ•°ï¼ˆaccumulatorï¼‰ä¼˜åŒ–é€’å½’ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> reverseList [1, 2, 3, 4]
[4,3,2,1]

>>> reverseList "hello"
"olleh"

è¿™ä¸ªå®ç°ä½¿ç”¨äº†å°¾é€’å½’ä¼˜åŒ–ï¼š
- reverseHelper æ˜¯ä¸€ä¸ªè¾…åŠ©å‡½æ•°
- acc (accumulator) ç´¯ç§¯ç»“æœ
- æ¯æ¬¡å°†å¤´å…ƒç´ æ·»åŠ åˆ°ç´¯ç§¯ç»“æœçš„å‰é¢
-}
reverseList :: [a] -> [a]
reverseList list = reverseHelper list []
  where
    reverseHelper [] acc     = acc
    reverseHelper (x:xs) acc = reverseHelper xs (x:acc)

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. æ·»åŠ è°ƒè¯•ä¿¡æ¯ï¼Œæ‰“å°æ¯ä¸€æ­¥çš„ accï¼ˆæç¤ºï¼šä½¿ç”¨ traceï¼‰
-- 2. å®ç°ä¸€ä¸ªç®€å•ç‰ˆæœ¬ï¼Œä¸ä½¿ç”¨ accumulator
-- 3. æ¯”è¾ƒä¸¤ä¸ªç‰ˆæœ¬åœ¨å¤§åˆ—è¡¨ä¸Šçš„æ€§èƒ½


-- ========================================
-- ç¤ºä¾‹ 5ï¼šé«˜é˜¶å‡½æ•° - è‡ªå®šä¹‰ map
-- ========================================

{- |
ç¤ºä¾‹ï¼šmyMap

å®ç°æˆ‘ä»¬è‡ªå·±çš„ map å‡½æ•°ï¼Œå¸®åŠ©ç†è§£é«˜é˜¶å‡½æ•°çš„å·¥ä½œåŸç†ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> myMap (*2) [1, 2, 3]
[2,4,6]

>>> myMap (++ "!") ["hello", "world"]
["hello!","world!"]

ç†è§£ï¼š
- myMap æ¥æ”¶ä¸€ä¸ªå‡½æ•° f å’Œä¸€ä¸ªåˆ—è¡¨
- å°†å‡½æ•° f åº”ç”¨åˆ°åˆ—è¡¨çš„æ¯ä¸ªå…ƒç´ 
- è¿”å›æ–°åˆ—è¡¨
-}
myMap :: (a -> b) -> [a] -> [b]
myMap _ []     = []
myMap f (x:xs) = f x : myMap f xs

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. å®ç° myFilterï¼šè‡ªå®šä¹‰ filter å‡½æ•°
-- 2. å®ç° myZipWithï¼šè‡ªå®šä¹‰ zipWith å‡½æ•°
-- 3. å®ç° myFoldlï¼šè‡ªå®šä¹‰ foldl å‡½æ•°


-- ========================================
-- ç¤ºä¾‹ 6ï¼šé«˜é˜¶å‡½æ•° - å‡½æ•°ä½œä¸ºè¿”å›å€¼
-- ========================================

{- |
ç¤ºä¾‹ï¼šmakeAdder

åˆ›å»ºä¸€ä¸ª"åŠ æ³•å™¨å·¥å‚"ï¼Œè¿”å›ä¸€ä¸ªåŠ æ³•å‡½æ•°ã€‚
å±•ç¤ºäº†å‡½æ•°å¯ä»¥è¿”å›å‡½æ•°ï¼ˆé—­åŒ…ï¼‰ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> let add5 = makeAdder 5
>>> add5 10
15

>>> let add100 = makeAdder 100
>>> add100 23
123

è¿™å±•ç¤ºäº†æŸ¯é‡ŒåŒ–å’Œéƒ¨åˆ†åº”ç”¨çš„æ¦‚å¿µã€‚
-}
makeAdder :: Int -> (Int -> Int)
makeAdder n = \x -> n + x

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. å®ç° makeMultiplierï¼šåˆ›å»ºä¹˜æ³•å™¨
-- 2. å®ç° makePowerOfï¼šåˆ›å»ºå¹‚å‡½æ•°ï¼ˆx^nï¼‰
-- 3. ç»„åˆä¸¤ä¸ª"å·¥å‚"ï¼šå…ˆä¹˜ååŠ 


-- ========================================
-- ç¤ºä¾‹ 7ï¼šæ¨¡å¼åŒ¹é… - åˆ—è¡¨è§£æ„
-- ========================================

{- |
ç¤ºä¾‹ï¼šdescribeList

ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥æè¿°åˆ—è¡¨çš„ç»“æ„ã€‚
å±•ç¤ºäº† Haskell å¼ºå¤§çš„æ¨¡å¼åŒ¹é…èƒ½åŠ›ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> describeList []
"Empty list"

>>> describeList [1]
"Single element: 1"

>>> describeList [1, 2]
"Two elements: 1 and 2"

>>> describeList [1, 2, 3, 4]
"Multiple elements, first: 1, second: 2"
-}
describeList :: Show a => [a] -> String
describeList []         = "Empty list"
describeList [x]        = "Single element: " ++ show x
describeList [x, y]     = "Two elements: " ++ show x ++ " and " ++ show y
describeList (x:y:_)    = "Multiple elements, first: " ++ show x ++ ", second: " ++ show y

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. æ·»åŠ å¯¹ä¸‰ä¸ªå…ƒç´ åˆ—è¡¨çš„ç‰¹æ®Šå¤„ç†
-- 2. ä¿®æ”¹æœ€åä¸€ä¸ªæ¨¡å¼ï¼Œæ˜¾ç¤ºå‰ä¸‰ä¸ªå…ƒç´ 
-- 3. å®ç° safeTailï¼šå®‰å…¨çš„ tail å‡½æ•°ï¼Œè¿”å› Maybe


-- ========================================
-- ç¤ºä¾‹ 8ï¼šGuards - å¤šæ¡ä»¶åˆ¤æ–­
-- ========================================

{- |
ç¤ºä¾‹ï¼šgradeToDescription

ä½¿ç”¨ guards æ ¹æ®åˆ†æ•°ç»™å‡ºç­‰çº§æè¿°ã€‚
å±•ç¤ºäº† guards æ¯” if-then-else æ›´æ¸…æ™°çš„åœºæ™¯ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> gradeToDescription 95
"ä¼˜ç§€ (Excellent)"

>>> gradeToDescription 75
"è‰¯å¥½ (Good)"

>>> gradeToDescription 55
"ä¸åŠæ ¼ (Fail)"
-}
gradeToDescription :: Int -> String
gradeToDescription score
    | score >= 90 = "ä¼˜ç§€ (Excellent)"
    | score >= 80 = "è‰¯å¥½ (Good)"
    | score >= 70 = "ä¸­ç­‰ (Average)"
    | score >= 60 = "åŠæ ¼ (Pass)"
    | otherwise   = "ä¸åŠæ ¼ (Fail)"

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. è°ƒæ•´åˆ†æ•°åŒºé—´
-- 2. æ·»åŠ å¯¹æ— æ•ˆåˆ†æ•°ï¼ˆ<0 æˆ– >100ï¼‰çš„å¤„ç†
-- 3. è¿”å›ä¸€ä¸ªåŒ…å«å­—æ¯ç­‰çº§çš„å…ƒç»„ï¼Œå¦‚ ("A", "ä¼˜ç§€")


-- ========================================
-- ç¤ºä¾‹ 9ï¼šlet å’Œ where - å±€éƒ¨å®šä¹‰
-- ========================================

{- |
ç¤ºä¾‹ï¼šquadraticRoots

è®¡ç®—ä¸€å…ƒäºŒæ¬¡æ–¹ç¨‹çš„æ ¹ã€‚
å±•ç¤ºäº†ä½¿ç”¨ let-in å’Œ where å®šä¹‰å±€éƒ¨å˜é‡ã€‚

å…¬å¼ï¼šaxÂ² + bx + c = 0
æ ¹ï¼šx = (-b Â± âˆš(bÂ² - 4ac)) / 2a

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> quadraticRoots 1 (-5) 6
(3.0, 2.0)
-- æ–¹ç¨‹ xÂ² - 5x + 6 = 0 çš„æ ¹æ˜¯ 3 å’Œ 2

>>> quadraticRoots 1 0 (-4)
(2.0, -2.0)
-- æ–¹ç¨‹ xÂ² - 4 = 0 çš„æ ¹æ˜¯ 2 å’Œ -2
-}
quadraticRoots :: Double -> Double -> Double -> (Double, Double)
quadraticRoots a b c = (root1, root2)
  where
    discriminant = b * b - 4 * a * c
    sqrtDiscriminant = sqrt discriminant
    root1 = (-b + sqrtDiscriminant) / (2 * a)
    root2 = (-b - sqrtDiscriminant) / (2 * a)

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. é‡å†™ä¸ºä½¿ç”¨ let-in ä»£æ›¿ where
-- 2. æ·»åŠ å¯¹åˆ¤åˆ«å¼ < 0 çš„å¤„ç†ï¼ˆè¿”å› Maybe æˆ–é”™è¯¯ä¿¡æ¯ï¼‰
-- 3. æ ¼å¼åŒ–è¾“å‡ºä¸ºå­—ç¬¦ä¸²


-- ========================================
-- ç¤ºä¾‹ 10ï¼šåˆ—è¡¨æ¨å¯¼å¼
-- ========================================

{- |
ç¤ºä¾‹ï¼špythagoras

ä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼æ‰¾å‡ºæ‰€æœ‰å‹¾è‚¡æ•°ï¼ˆaÂ² + bÂ² = cÂ²ï¼‰ï¼Œå…¶ä¸­ a, b, c â‰¤ limitã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> pythagoras 20
[(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(8,15,17),(9,12,15),(12,5,13),(12,9,15),(15,8,17)]

åˆ—è¡¨æ¨å¯¼å¼è¯­æ³•ï¼š
[ expression | generator, condition ]
-}
pythagoras :: Int -> [(Int, Int, Int)]
pythagoras limit =
    [ (a, b, c)
    | a <- [1..limit]
    , b <- [1..limit]
    , c <- [1..limit]
    , a * a + b * b == c * c
    ]

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. æ·»åŠ æ¡ä»¶ a < b < c ä»¥é¿å…é‡å¤
-- 2. åªè¿”å›å‘¨é•¿å°äº 50 çš„å‹¾è‚¡æ•°
-- 3. ä½¿ç”¨åˆ—è¡¨æ¨å¯¼å¼å®ç° FizzBuzz


-- ========================================
-- ç¤ºä¾‹ 11ï¼šæƒ°æ€§æ±‚å€¼çš„å¨åŠ›
-- ========================================

{- |
ç¤ºä¾‹ï¼šinfiniteList

å±•ç¤º Haskell çš„æƒ°æ€§æ±‚å€¼ç‰¹æ€§ã€‚
æˆ‘ä»¬å¯ä»¥å®šä¹‰æ— é™åˆ—è¡¨ï¼Œä½†åªè®¡ç®—éœ€è¦çš„éƒ¨åˆ†ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> take 10 infiniteOnes
[1,1,1,1,1,1,1,1,1,1]

>>> take 5 infiniteNaturals
[1,2,3,4,5]

>>> take 10 fibonacciNumbers
[1,1,2,3,5,8,13,21,34,55]
-}

-- æ— é™ä¸ª 1
infiniteOnes :: [Int]
infiniteOnes = 1 : infiniteOnes

-- æ— é™çš„è‡ªç„¶æ•°åºåˆ—
infiniteNaturals :: [Int]
infiniteNaturals = [1..]

-- æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ˆæ— é™ï¼‰
fibonacciNumbers :: [Int]
fibonacciNumbers = 1 : 1 : zipWith (+) fibonacciNumbers (tail fibonacciNumbers)

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. å®šä¹‰æ— é™çš„å¶æ•°åºåˆ—
-- 2. å®šä¹‰æ— é™çš„å¹³æ–¹æ•°åºåˆ— [1, 4, 9, 16, ...]
-- 3. ç†è§£ fibonacciNumbers çš„å·¥ä½œåŸç†ï¼ˆç”»å›¾ï¼ï¼‰


-- ========================================
-- ç¤ºä¾‹ 12ï¼šç»„åˆæ‰€æœ‰æ¦‚å¿µ - æ–‡æœ¬åˆ†æ
-- ========================================

{- |
ç¤ºä¾‹ï¼šanalyzeText

ç»„åˆå¤šä¸ªæ¦‚å¿µï¼šå­—ç¬¦ä¸²å¤„ç†ã€åˆ—è¡¨æ“ä½œã€é«˜é˜¶å‡½æ•°ã€‚
åˆ†æä¸€æ®µæ–‡æœ¬ï¼Œè¿”å›ç»Ÿè®¡ä¿¡æ¯ã€‚

ä½¿ç”¨ç¤ºä¾‹ï¼š
>>> analyzeText "Hello world! This is Haskell."
"Words: 5, Chars: 30, Avg word length: 4.80"

åŠŸèƒ½ï¼š
- ç»Ÿè®¡å•è¯æ•°
- ç»Ÿè®¡å­—ç¬¦æ•°
- è®¡ç®—å¹³å‡å•è¯é•¿åº¦
-}
analyzeText :: String -> String
analyzeText text = "Words: " ++ show wordCount
                ++ ", Chars: " ++ show charCount
                ++ ", Avg word length: " ++ show avgLength
  where
    wordsList = words text
    wordCount = length wordsList
    charCount = length text
    totalWordChars = sum (map length wordsList)
    avgLength = fromIntegral totalWordChars / fromIntegral wordCount :: Double

-- å°è¯•ä¿®æ”¹ï¼š
-- 1. æ·»åŠ æœ€é•¿å•è¯çš„é•¿åº¦
-- 2. æ·»åŠ æœ€çŸ­å•è¯çš„é•¿åº¦
-- 3. ç»Ÿè®¡æ¯ä¸ªå­—æ¯å‡ºç°çš„é¢‘ç‡ï¼ˆæç¤ºï¼šä½¿ç”¨ filter å’Œ lengthï¼‰
-- 4. è¿”å›ä¸€ä¸ªè®°å½•ç±»å‹è€Œä¸æ˜¯å­—ç¬¦ä¸²


-- ========================================
-- æ­å–œå®Œæˆäº’åŠ¨ç¤ºä¾‹ï¼
-- ========================================

{- |
å¤ªæ£’äº†ï¼

é€šè¿‡è¿™äº›äº’åŠ¨ç¤ºä¾‹ï¼Œä½ æ·±å…¥ç†è§£äº†ï¼š
âœ“ å‡½æ•°ç»„åˆå’Œç®¡é“
âœ“ é€’å½’æ¨¡å¼å’Œä¼˜åŒ–
âœ“ é«˜é˜¶å‡½æ•°çš„å¼ºå¤§ä¹‹å¤„
âœ“ æ¨¡å¼åŒ¹é…çš„çµæ´»æ€§
âœ“ Guardsã€letã€where çš„ä½¿ç”¨åœºæ™¯
âœ“ åˆ—è¡¨æ¨å¯¼å¼
âœ“ æƒ°æ€§æ±‚å€¼çš„ä¼˜åŠ¿

ä¸‹ä¸€æ­¥ï¼š
1. å®é™…ä¿®æ”¹æ¯ä¸ªç¤ºä¾‹ï¼Œè§‚å¯Ÿè¡Œä¸ºå˜åŒ–
2. åœ¨ GHCi ä¸­å®éªŒä¸åŒçš„è¾“å…¥
3. å°è¯•ç»„åˆå¤šä¸ªç¤ºä¾‹çš„æŠ€å·§
4. å‡†å¤‡æŒ‘æˆ˜ Challenges.hsï¼

ä½ æ­£åœ¨æˆä¸º Haskell é«˜æ‰‹ï¼Keep exploring! ğŸš€
-}
